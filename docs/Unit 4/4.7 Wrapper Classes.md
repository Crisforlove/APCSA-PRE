### Topic 4.7 â€” Wrapper Classes

#### 1
What is the result of d1 + d2 + d3.doubleValue() + d4 if the four Double objects sum to 100.0?

- A) 100.0
- B) "100.0"
- C) 100
- D) A compile-time error.
- E) A memory address.

Answer: A

#### 2
Given `Integer val = 10;`, what is printed after `Integer r2 = timesTwo(val);` executes (assume `timesTwo` returns int 20)?

- A) 10
- B) 20
- C) 0
- D) null
- E) A syntax error due to autoboxing.

Answer: B

#### 3
Given `Double y = x / 2.0; y /= 2;` where x is 3. What does `y.doubleValue()` return?

- A) 0.0
- B) 0.5
- C) 0.75
- D) 1.0
- E) 1.5

Answer: C

#### 4
Which code segment correctly stores a random integer between 1 and 10 inclusive into an Integer object?

- A) (int)(Math.random()) * 10
- B) (int)(Math.random()) * 10 + 1
- C) (int)(Math.random() * 10)
- D) (int)(Math.random() * 10) + 1
- E) (int)(Math.random() + 1) * 10

Answer: D

#### 5
Is the assignment `Double d = 20.0; double x = d;` legal in the AP Java subset?

- A) No, it requires an explicit cast.
- B) Yes, it is legal due to automatic unboxing.
- C) Yes, but only if x is initialized to 0.
- D) No, Double cannot be converted to double.
- E) No, it causes a precision loss error.

Answer: B

#### 6
Comparing two Integer objects a and b (value 128) using a == b may return false because:

- A) The values are different.
- B) == compares memory references, not content, for objects outside the cache range.
- C) Integer does not support ==.
- D) One object is automatically unboxed.
- E) 128 is a prime number in Java logic.

Answer: B

#### 7
Which is the preferred method to obtain an Integer from an int for efficiency?

- A) new Integer(5)
- B) Integer.valueOf(5)
- C) Integer.parseInt(5)
- D) Integer.toString(5)
- E) (Integer) 5

Answer: B

#### 8
`Integer.parseInt("42")` returns an int; what does `Integer.valueOf("42")` return?

- A) int
- B) Integer object
- C) String
- D) double
- E) void

Answer: B

#### 9
When rounding a **negative** double d to the nearest integer, which formula is correct?

- A) (int)(d + 0.5)
- B) (int)(d - 0.5)
- C) Math.abs(d)
- D) (int)d
- E) Math.round(d)

Answer: B

#### 10
Why is 0.1 + 0.2 == 0.3 potentially false in Java?

- A) Double objects are immutable.
- B) Round-off errors occur in floating-point representations.
- C) The + operator is not for doubles.
- D) Types must be BigDecimal.
- E) It is always true.

Answer: B
